# ===================================================================
# channel.yaml (Version 8 - Kompatibel med nyeste ESPHome)
# RETTELSE: Lambda-funktioner er justeret til at læse korrekte
#           dataindekser for den nye modbus_controller.
# ===================================================================

# ----------- Sensor ----------- #
sensor:
  - platform:               modbus_controller
    name:                   "${entity_name} Temperature"
    id:                     ${entity_id}_temperature
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               ${entity_hide_temperature_sensor}
    custom_command: [0x01, 0x43, 0x01, 0x04, $channel_sensor_id, 0x01]
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    device_class: temperature
    force_update: True
    lambda: |-
      // RETTELSE: Bytter om på data[0] og data[1]
      uint16_t raw_temp = (data[1] << 8) | data[0];
      if (raw_temp == 0x7FFF) return NAN;
      return raw_temp * 0.1;

  - platform:               modbus_controller
    name:                   "${entity_name} Battery"
    id:                     ${entity_id}_battery
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               ${entity_hide_battery_sensor}
    custom_command: [0x01, 0x43, 0x01, 0x0A, $channel_sensor_id, 0x01]
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: battery
    entity_category: diagnostic
    lambda: |-
      // RETTELSE: Bytter om på bytes og bruger korrekt logik
      uint16_t raw_value = (data[1] << 8) | data[0];
      uint8_t battery_level_raw = raw_value & 0x000F;
      if (battery_level_raw > 10) return id(${entity_id}_battery).state;
      return battery_level_raw * 10.0;

# ----------- Binary ----------- #
binary_sensor:
  - platform:               modbus_controller
    name:                   "${entity_name} Output"
    id:                     ${entity_id}_output
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               true # Bør være intern, da den kun bruges af climate-enheden
    custom_command: [0x01, 0x43, 0x03, 0x00, $channel_id, 0x01]
    bitmask: 0x0010

# ----------- Number ----------- #
number:
  - platform:               modbus_controller
    name:                   "${entity_name} Target Temperature"
    id:                     ${entity_id}_target_temperature
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               true
    custom_command: [0x01, 0x43, 0x02, 0x00, $channel_id, 0x01]
    value_type: U_WORD
    unit_of_measurement: "°C"
    min_value: 6
    max_value: 40
    step: .5
    write_lambda: |-
      uint16_t targettemp = x * 10;
      // write_lambda er uændret, da den bygger en komplet pakke
      payload.push_back(0x01);
      payload.push_back(0x44);
      payload.push_back(0x02);
      payload.push_back(0x00);
      payload.push_back(${channel_id});
      payload.push_back(0x01);
      payload.push_back(targettemp >> 8);
      payload.push_back(targettemp & 0xFF);
      return true;
    lambda: |-
      // NYT: Læser fra data[0] og data[1]
      uint16_t raw_temp = (data[0] << 8) | data[1];
      return raw_temp * 0.1;

# ----------- Switch ----------- #
switch:
  - platform:               modbus_controller
    name:                   "${entity_name} Standby"
    id:                     ${entity_id}_standby
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               true
    custom_command: [0x01, 0x43, 0x02, 0x07, $channel_id, 0x01]
    # write_lambda er uændret
    write_lambda: |-
      uint8_t MODE_MASK = 0x07;
      payload.push_back(0x01);
      payload.push_back(0x45);
      payload.push_back(0x02);
      payload.push_back(0x07); 
      payload.push_back(${channel_id});
      payload.push_back(0x01); 
      if(x) {
        payload.push_back(0x00);
        payload.push_back(0x01);
      } else {
        payload.push_back(0x00);
        payload.push_back(0x00);
      }
      payload.push_back((~MODE_MASK) >> 8);
      payload.push_back((~MODE_MASK) & 0xFF);
      return true;
    lambda: |-
      // NYT: Læser fra data[0] og data[1]
      uint16_t mode_reg = (data[0] << 8) | data[1];
      return (mode_reg & 0x07) == 1 && !((mode_reg >> 3) & 0x01);

# ----------- Climate ----------- #
climate:
  - platform:               wavin_ahc9000
    name:                   ${entity_name}
    current_temp_sensor_id: ${entity_id}_temperature
    target_temp_number_id:  ${entity_id}_target_temperature
    mode_switch_sensor_id:  ${entity_id}_standby
    action_sensor_id:       ${entity_id}_output
    visual:
      temperature_step:
        current_temperature: 0.1
        target_temperature: 0.5

