# ----------- Sensor ----------- #
sensor:
  - platform:               modbus_controller
    name:                   ${entity_name} Temperature
    id:                     ${entity_id}_temperature
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               ${entity_hide_temperature_sensor}
    custom_command: 
      - 0x01
      - 0x43
      - 0x01
      - 0x04
      - $channel_sensor_id
      - 0x01
    value_type: U_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    device_class: temperature
    force_update: True
    lambda: |-
      for (int i = 0; i < data.size(); i++) {
        ESP_LOGD("DEBUG", "data[%d] = 0x%02X", i, data[i]);
      }
      uint16_t raw_temp = (data[2] << 8) | data[3];
      ESP_LOGD("DEBUG", "Correct raw_temp assembled: %d", raw_temp);
      return raw_temp * 0.1;
  # Battery
  - platform:               modbus_controller
    name:                   ${entity_name} Battery
    id:                     ${entity_id}_battery
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               ${entity_hide_battery_sensor}
    custom_command: 
      - 0x01
      - 0x43
      - 0x01
      - 0x0A
      - $channel_sensor_id
      - 0x01
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 0
    device_class: battery
    entity_category: diagnostic
    lambda: |-
      uint16_t raw_battery = (data[2] << 8) | data[3];
      ESP_LOGD("DEBUG", "Battery raw value: %d", raw_battery);
      return raw_battery * 10.0;

  - platform:               modbus_controller
    name:                   ${entity_name} test
    id:                     ${entity_id}_test
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               false
    custom_command:
      - 0x01
      - 0x43
      - 0x03          # Category: Channels
      - 0x00          # Register Index: TIMER EVENT
      - $channel_id   # Register Page
      - 0x01
    filters:
      # Isolerer de nederste 4 bits (TEVENT[3:0])
      - lambda: return (int)x & 0x000F;


# ----------- Binary ----------- #
binary_sensor:
  - platform:               template
    name:                   "${entity_name} Heating Action"
    id:                     ${entity_id}_output
    internal:               false
    lambda: |-
      auto event_value = id(${entity_id}_test).state;
      // Værdierne 0, 1 og 2 er "OFF" tilstande. Alt andet er "ON".
      if (event_value == 0 || event_value == 1 || event_value == 2) {
        return false; // Idle
      } else {
        return true;  // Heating
      }

# ----------- Number ----------- #
number:
  - platform:               modbus_controller
    name:                   ${entity_name} Target Temperature
    id:                     ${entity_id}_target_temperature
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               true
    custom_command: 
      - 0x01
      - 0x43
      - 0x02
      - 0x00
      - $channel_id
      - 0x01
    value_type: U_WORD
    unit_of_measurement: "°C"
    min_value: 6
    max_value: 40
    step: .5
    write_lambda: |-
      ESP_LOGD("DEBUG", "Trying to write new target temp: %f", x);
      uint16_t targettemp = x * 10;
      payload.push_back(0x0144);
      payload.push_back(0x0200);
      payload.push_back(${channel_id}01);
      payload.push_back(targettemp);
      return true;
    lambda: |-
      uint16_t raw_temp = (data[2] << 8) | data[3];
      ESP_LOGD("DEBUG", "Target temp raw value: %d", raw_temp);
      return raw_temp * 0.1;

# ----------- Switch ----------- #
switch:
  - platform:               modbus_controller
    name:                   ${entity_name} Standby
    id:                     ${entity_id}_standby
    modbus_controller_id:   ${device_id}_modbus_controller
    internal:               true
    custom_command:
      - 0x01
      - 0x43
      - 0x02
      - 0x07
      - $channel_id
      - 0x01
    write_lambda: |-
      // Payload skal KUN indeholde data-bytes, ikke slave ID og funktionskode.
      // Format for 0x45: [Category, Index, Page, Quantity, Data_H, Data_L, Mask_H, Mask_L]
      std::vector<uint8_t> payload;
      payload.push_back(0x02); // Category: Packed Data
      payload.push_back(0x07); // Index: CONFIGURATION
      payload.push_back(${channel_id});
      payload.push_back(0x01); // Quantity

      if (x) {
        // Sæt til Standby (SCHED_ENA=0, MODE=1 => værdi 0x01)
        payload.push_back(0x00); // Data High
        payload.push_back(0x01); // Data Low
      } else {
        // Sæt til Week Schedule (SCHED_ENA=1, MODE=0 => værdi 0x08)
        payload.push_back(0x00); // Data High
        payload.push_back(0x08); // Data Low
      }

      // Maske til kun at ændre de nederste 4 bits (mode + sched)
      // Mask = 0xFFF0
      payload.push_back(0xFF); // Mask High
      payload.push_back(0xF0); // Mask Low
      
      return modbus_controller::write_custom_command(payload, 0x45);
    lambda: |-
      uint16_t config_reg = (data[2] << 8) | data[3];
      uint8_t mode_bits = config_reg & 0x07;
      bool sched_ena = (config_reg >> 3) & 0x01;
      // Switchen er ON (Standby) hvis mode er "PERMANENT STANDBY"
      if (!sched_ena && mode_bits == 1) {
        return true;
      }
      return false;

# ----------- Climate ----------- #
climate:
  - platform:               wavin_ahc9000
    name:                   ${entity_name}
    current_temp_sensor_id: ${entity_id}_temperature
    target_temp_number_id:  ${entity_id}_target_temperature
    mode_switch_sensor_id:  ${entity_id}_standby
    action_sensor_id:       ${entity_id}_output
    visual:
      temperature_step:
        current_temperature: 0.1
        target_temperature: 0.5










